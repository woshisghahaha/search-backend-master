{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1718574992498749442",
        "title": "分布式Session登录",
        "description": "一篇带你彻底理解怎么使用分布式登录的文章",
        "content": "\n# 了解cookie\n\n**Cookie是在Web服务器和Web浏览器之间传递的一小段数据，用于在浏览器和服务器之间维持会话状态。保存session（通过身份验证后服务端为用户创建一个会话标识符）**\n想象一下你去一家咖啡店。你点了一杯咖啡，并且收银员给你一张小纸条，上面写着你的订单号码。你拿着这张小纸条，然后坐下来等待你的咖啡。当咖啡准备好后，服务员会根据你手上的订单号码找到你，并把咖啡送到你的桌子上。\n在这个例子中，订单号码就像是一个cookie。它是一个小的标识符，帮助咖啡店识别你的订单。当你拿着订单号码坐下时，咖啡店就知道你是谁，并准备好你的咖啡。这样，无论你是在咖啡店的哪个位置，他们都可以准确地为你提供服务。\n**那么cookie可以用来做什么呢？我们从三个主要的功能来讲解它。**\n\n1. 身份验证：Cookie在身份验证方面发挥重要作用。当你登录一个网站时，网站通常会生成一个用于身份验证的cookie，并将其存储在你的浏览器中。这个cookie包含一个加密的唯一标识符，用于识别你的身份。在之后的请求中，浏览器会将该cookie发送给服务器，以便服务器确认你的身份，并允许你访问需要登录的受限资源。\n2. 会话管理：另一个重要的作用是在网站的会话管理中。当你与网站进行交互时，服务器会为你创建一个会话，并生成一个唯一的会话标识符（也就是session）。这个标识符通常以cookie的形式发送给你的浏览器。浏览器会在后续的请求中将该cookie发送回服务器，以便服务器识别你的会话，并在会话期间跟踪你的状态和数据。这使得网站能够在多个页面之间保持用户的连贯性，例如保存购物车中的商品或记录浏览历史。\n3. 持久登录：有时候，网站提供了“记住我”或“保持登录状态”的选项，这需要使用持久登录（也称为“持久性会话”）来实现。当你选择记住登录状态时，网站会在你的浏览器中设置一个持久性的cookie。这个cookie通常具有较长的过期时间，甚至可以保持几天或几周。当你关闭浏览器或重新启动计算机后，这个cookie仍然存在，使得你在下次访问网站时无需重新登录。持久登录提供了方便性，但也需要谨慎使用，以确保安全性和隐私保护。\n了解完cookie是什么，有什么作用，让我们展开今天的主题！\n\n## 问题引入\n\n比如我现在有两个域名：\nA.com\nB.com\n思考一个假设我的cookie是在A.com上，如果B.com想访问A.com的cookie能访问到吗？\n答案是不能访问到的，因为我们的cookie是种在A.com的域名上，即使B.com通过前台发送请求给后台，因为B.com向后台发送请求时是不会带上A.com这个cookie的。\n\n**因此如果想要共享cookie，可以种一个更高层的公共域名，比如xhl.com，那么在子层的域名就能共享到cookie，A.com和B.com这两个域名就能具有同一个cookie。**\n\n\n## 为什么服务器A登录后，请求发送给服务器B，不认识该用户呢？\n\n用户在A 登录，session（用户登录的信息）是存在A上的，当用户去请求B服务器的时候，由于没有存储用户信息，所以不认识。\n想象一下，你正在参加一个大型音乐节，音乐节的入口处有一个安检站。你来到安检站，安检员检查你的票和身份，并在你的手腕上贴上一个标签，以表示你已经通过了安检。\n现在，你已经通过了安检，并且在音乐节内自由地漫步。在演出期间，你想去音乐节场地外的一个小吃摊购买一些食物。然而，当你到达小吃摊时，他们并不知道你已经通过了安检，并且没有给你贴上标签。因此，他们无法确认你是否已经接受了安检，无法提供给你服务。\n\n\n\n## 如何实现共享数据存储？\n\n实现共享数据存储有多种方法，下面我将介绍几种常见的方法，并列出它们的优缺点：\n1. 数据库共享：使用共享数据库是一种常见的实现方式。多个服务器可以连接到同一个数据库，并共享数据。这种方法的优点是数据一致性高，所有服务器都可以读取和写入相同的数据。然而，数据库的性能可能成为瓶颈，特别是在高并发的情况下，需要谨慎设计和调优。\n2. **分布式缓存**：使用分布式缓存系统（例如Redis或Memcached）来存储共享数据是另一种常见的方法。多个服务器可以通过连接到同一个分布式缓存来读取和写入数据。这种方法的优点是缓存系统通常具有快速的读写性能，并且可以水平扩展。然而，需要注意的是，缓存系统通常是基于内存的，因此对于大量的数据或需要持久化的数据，需要谨慎处理。\n3. 分布式文件系统：使用分布式文件系统（例如Hadoop的HDFS或GlusterFS）可以实现共享数据存储。多个服务器可以连接到同一个文件系统，并在其中读取和写入数据。这种方法的优点是文件系统通常具有高容量和高可靠性，并且支持并发访问。然而，文件系统的一致性可能需要额外的管理和协调。\n4. 分布式数据库：使用分布式数据库系统（例如Cassandra、MongoDB或Spanner）可以实现共享数据存储。这种方法将数据分散存储在多个节点上，并提供数据的一致性和可用性。优点包括横向扩展和高可用性，但需要考虑数据分片、复制和一致性的管理。\n具体来说：\n\n- **redis**（基于内存的 K / V 数据库）\n因为用户信息读取/是否登录的判断极其频繁，Redis基于内存，读写性能很高，简单的数据单机qps 5w-10w\n- QPS：意思是每秒查询率，指一台服务器每秒能够响应的查询次数，用于衡定特定的查询服务器在规定的时间内所处理流量多少，主要针对专门用于查询的服务器的性能指标。\n- MySQL\n文件服务器ceph\n\n# 使用redis实现session共享\n\n## 基本原理\n\n使用**Redis实现会话（Session）共享的原理是将会话数据存储在Redis数据库中**，从而使多个服务器能够共享和访问相同的会话数据。下面是使用Redis实现会话共享的基本原理：\n1. 配置Redis：首先，需要在多个服务器上安装和配置Redis数据库。确保所有服务器都能够连接到相同的Redis实例。\n生成会话ID：当用户在其中一个服务器上登录时，会为其生成一个唯一的会话ID。这个会话ID可以是一个随机生成的字符串或其他唯一标识符。\n2. 存储会话数据：将用户的会话数据存储在Redis中。可以使用Redis的字符串数据结构来存储会话数据，其中会话ID作为键，会话数据作为值。可以使用Redis的SET或HMSET命令来设置会话数据。\n3. 将会话ID发送给客户端：将生成的会话ID发送给客户端，通常通过将会话ID存储在cookie中。客户端的浏览器会在后续的请求中将该cookie发送回服务器。\n4. 从Redis中检索会话数据：当客户端发送请求到其他服务器时，服务器会从Redis中检索会话数据。通过读取请求中的会话ID，服务器可以使用Redis的GET或HMGET命令从Redis中获取存储的会话数据。\n处理会话数据：服务器可以使用获取到的会话数据来验证用户身份、获取用户配置或执行其他与会话相关的操作。\n\n实现步骤\n\n\n1. 下载redis ，官网：https://redis.io/\n2. 下载redis管理工具quick redis：https://quick123.net/\n3. 引入redis，在springboot中操作redis\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    <version>2.6.4</version>\n</dependency>\n```\n\n\n\n4. 引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis -->\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-data-redis</artifactId>\n    <version>2.6.3</version>\n</dependency>\n```\n\n\n\n5. 修改 spring-session 存储配置 spring.session.store-type，默认是none，表示存储在单台服务器，store-type: redis，表示从 redis 读写 session。\nsession 失效时间\n\n```xml\nsession:\n  timeout: 86400\n  store-type: redis\n\n```\n\n\n然后我们就可以写一个单元测试，写一个@Resource注解引入redis并操作了。\n\n",
        "category": "文章",
        "cover": "https://pic.study/post_cover/1612112775822180354/lSNtctcZ-2c6cc12ecc1d461a95879314f0c6adf9.png",
        "language": null,
        "viewNum": 37,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1612112775822180354",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-29T10:26:22.000+00:00",
        "updateTime": "2023-11-02T04:05:54.000+00:00",
        "user": {
          "id": "1612112775822180354",
          "planetCode": "4838",
          "userName": "小火龙",
          "userAvatar": "https://pic.study/user_avatar/1612112775822180354/4fsjvVfu-R.jpg",
          "gender": 1,
          "userProfile": "计算机科学与技术专业本科在读，热爱生活，热爱技术。",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": "计算机科学与技术",
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 35,
          "coin": 270,
          "followeeNum": 7,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-01T01:02:21.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-08T15:43:32.000+00:00",
          "updateTime": "2023-10-29T10:33:58.000+00:00"
        },
        "tags": [
          "文章",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1717906639580950530",
        "title": "MySQL常见的性能优化方法技巧以及示例",
        "description": "MySQL常见的性能优化方法介绍，为什么能实现优化，具体代码示例",
        "content": "\n![logo.png](https://pic.study/post_picture/1609742938097582081/6SPlIrLq-logo.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 22,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1609742938097582081",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-27T14:10:34.000+00:00",
        "updateTime": "2023-11-02T02:27:17.000+00:00",
        "user": {
          "id": "1609742938097582081",
          "planetCode": "958",
          "userName": "小马",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/9R5BLk13SjL1BEZoVjChNibGaTlfqxBeHt16B4OicOicriaDb5Gke5jCOl92vwBKsGYjKUsHmWv25K6h4oeTZhRxiaw/132",
          "gender": 1,
          "userProfile": "享受",
          "userRole": "vip",
          "interests": [
            "后端",
            "算法",
            "笔记"
          ],
          "place": null,
          "birthday": "2001-10-10",
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2024,
          "jobStatus": "求职中",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 20,
          "coin": 220,
          "followeeNum": 1,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-02-02T23:52:00.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-02T02:46:38.000+00:00",
          "updateTime": "2023-09-18T13:08:17.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1715744120913391618",
        "title": "Nextjs App Router 模式新能力",
        "description": "Next.js 13 App Router，一种新的前端编程模式，SEO友好的框架",
        "content": "nextjs 13.4 的发布，宣布 App Router 稳定版本的到来，\n\n!\n\n​\t上图是 next 的下载量，可以看到 **遥遥领先** 其他框架，vercel 公司的新一代 React 框架，为什么如此好用？下面我们看一下 13.4 版本的新功能吧！\n\n### App Router\n\n​\tNext.js 13.4 是第一个将新的应用程序目录和应用程序路由器功能从测试版中剔除的版本！这就代表着 App Router 正式成为稳定版，可以用于生产环境，相比较之前的` pages/` 下文件路由，`App Router`更加的自由，具体优势有：\n\n- 更灵活的路由规则：使用 \"app route\" 可以更自由地定义路由，不再仅依赖于文件的相对路径。这样可以更好地组织和管理路由结构，特别是对于复杂的应用程序而言。\n- 更好的代码分离：在 \"app route\" 中，可以将路由定义和页面逻辑分离到不同的文件或模块中。这样可以提高代码的可读性和可维护性。\n- 更好的代码重用：\"app route\" 支持模块化的路由定义和组合，使得页面的复用更加便利。您可以将一些共享的路由规则封装成模块，便于在不同的页面或应用中共享和复用。\n\napp route 使 Next 的开发体验变得更好，此外，Next.js 文档站点进行了重大更新，将 App Router 设为默认值，这也许象征着此版本的重要性！您现在可以在新的 App Router 和之前的 Pages Router 之间切换文档。\n\n\n\n#### App 文件下的路由\n\n新应用程序目录中的路由就像添加导出 React 函数组件的 `page.tsx` 文件一样简单。应用程序的路由由应用程序目录中文件夹的层次结构定义。例如，在 `/` 路由上创建页面就像在应用程序目录的根目录中添加 page.tsx 文件一样简单\n\n##### 1）新的路由规范\n\n接下来，让我们展示如何使用新的应用程序路由器创建更复杂的应用程序路由：\n\n\n\n正如您在上面看到的，我们能够创建一个简单的路由，例如 `/about` ，以及使用 Next.js 的动态路由创建更复杂的路由，例如 `/articles/article/12345` 。\n\n新的路由规范通过为布局、页面、模板等强制使用特殊文件名，解决了之前版本中所有文件都作为路由，无法在`pages/` 下声明不作为路由的文件，使开发体验变得更好。\n\n##### 2）获取数据方式更简洁\n\n借助新的 App Router，我们的页面可以使用 React Server 组件，这使我们能够使用熟悉的 async/await 语法来简化数据获取。\n\n```tsx\n// app/page.tsx\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/...');\n  const data = res.json();\n  return '...';\n}\n```\n\n在 12 的时候，我们想要获取数据需要：\n\n```tsx\n// pages/example.js\n\nimport React from 'react';\n\nexport async function getServerSideProps() {\n  // 在此处获取服务端数据\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  \n  return {\n    props: {\n      data // 将数据作为 props 返回\n    }\n  };\n}\n\nfunction Example({ data }) {\n  // 在客户端使用获取到的数据进行渲染\n  return (\n    <div>\n      <h1>Server-side rendering example</h1>\n      <p>{data}</p>\n    </div>\n  );\n}\n\nexport default Example;\n```\n\n相比较更加符合之前的开发习惯！\n\n##### 3）新的概念：服务器组件\n\n在 Next.js 13 中，**文件默认是服务器组件**。您可以通过在模块顶部包含 `'use client'` 指令来选择使用客户端组件。如果您还不了解客户端组件 和 服务器组件的区别，强烈推荐文章：[理解React服务器组件](https://www.joshwcomeau.com/react/server-components/)，这篇文章详细解释了为什么需要引入新的概念：服务器组件，以及客户端组件和服务端组件的边界问题，开发中容易混淆的概念等等，非常值得一看\n\n##### 4）路由段配置\n\n我们的页面还可以导出路由段，使我们能够控制页面的渲染方式。 Next.js 中的一种常见做法是静态生成页面。但是，当我们使用动态参数时，我们遇到了一个问题，Next.js 如何知道要静态生成哪些页面？我们可以利用 `generateStaticParams` 来解决这个问题。这在做 seo 中非常有用\n\n```tsx\n// app/articles/article/[id]/page.tsx\ntype ArticleProps = Pick<Article, 'id'>\n\nexport default async function Page({ id }: ArticleProps) {\n  const article = await(await fetchArticleById(id)).json();\n  return <BlogArticle article={article} />\n}\n\nexport async function generateStaticParams(): ArticleProps[] {\n  const articles = await(await fetchArticles()).json();\n  return articles.map(article => ({ id: article.id }))\n}\n```\n\n\n\n在上面的示例中，我们导出一个名为 `generateStaticParams` 的异步函数，该函数加载我们的所有博客文章并返回一个对象数组，该数组的属性与动态路线段的名称相匹配，在本例中为 `id` 。 Next.js 将使用它为我们的每篇博客文章静态生成页面。\n\n##### 5）路由段配置\n\nNext.js 13 为我们提供了几个[路由段配置](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config)选项来控制 Next.js 渲染页面的方式。除了 `generateStaticParams` 之外，最常用的路线段配置是 `revalidate` 。当与静态站点生成 (SSG) 结合使用时，重新验证允许您控制页面重新生成的频率。例如我在 page.tsx | route.ts | layout.ts 中，添加如下代码：\n\n```tsx\nexport const revalidate = 60\n```\n\n那么我们的当前页面就会每 60 秒重建一次页面，请注意，它比这更微妙，因此请务必阅读 Next.js 文档网站上的 ISR\n\n我们还可以通过使用 dynamicParams 路由段配置来告诉 next.js 不要渲染 `generateStaticParams` 中未返回的 ID 的页面，\n\n如果我们有一个使用查询参数的页面，我们可能希望在使用动态路由段请求该页面时动态服务器呈现它，那么我们可以根据我们的用例强制页面静态或动态生成\n\n```tsx\nexport dynamic = 'force-dynamic'\n// or: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n```\n\n##### 6）布局和模版\n\n**布局**\n\n除了页面之外，Next.js 13 还引入了**布局**和**模板**的特殊文件。在上面的示例中，您可能已经注意到，我们在文件夹层次结构的各个级别包含了多个 `layout.tsx` 文件。我们创建了一个根级 `layout.tsx`，这是 Next.js 13 中的典型做法。\n\n在根布局中，我们可以创建 HTML 文档，向头部添加脚本和其他内容，提供语义结构，并将应用程序包裹在供应器中。我们不再需要使用 Next.js 早期版本中的特殊 `<Head>` 和 `<Script>` 组件。我们也可以在这里添加**元数据**，\n\n请注意，`layout.tsx` 和`page.tsx`通常应该是服务器组件，因为我们应该让布局组件在服务器渲染，这样用户可以下载更少的 js，让用户更快看到一些内容。\n\n```tsx\n// app/layout.tsx\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <script>//...</script>\n      </head>\n      <body>\n        <main>\n           <AppProvider>{children}</AppProvider>\n        </main>      \n      </body>\n    </html>\n  );\n}\n\n// app/page.tsx\nexport default function Page() {\n  return //...;\n}\n```\n\n我们还可以在应用程序目录层次结构的每个级别添加布局文件，以将更具体的布局应用于应用程序的不同部分。例如，假设我们想要围绕我们的博客文章添加一个特定的 AppWrapper。我们可以将新的 `layout.tsx` 文件添加到 `page.tsx` 文件旁边的 `/app/articles/article/[id]` 目录中。\n\n```tsx\n// app/articles/article/[id]/layout.tsx\nexport default function RootLayout({ children }) {\n  return (\n    <AppWrapper>{children}</AppWrapper>\n  );\n}\n```\n\n**模版**\n\n模版和布局类似，但是区别在于，模版在不同路由之间切换的时候，模版的内容是销毁和重新新建，但是布局是对应路由下 共享这个 DOM 元素，路由切换不会销毁再新建DOM，\n\n更多请看：[路由之排版](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#templates)\n\n#### 自动代码分割\n\nNext.js 13.4 让**代码分割**和**动态加载内容**变得比以往更容易。在 之前版本中，您必须使用 `next/dynamic` 。现在，整个应用程序可以通过使用 `Suspense` 选择代码分割和动态加载。事实上，您可以在客户端组件中使用简单的条件进行代码分割。查看 Next.js 博客中的以下示例，该示例根据用户是否登录返回完全不同的包：\n\n```tsx\n// app/layout.tsx\nimport { getUser } from './auth';\nimport { Dashboard, Landing } from './components';\n\nexport default async function Layout() {\n  const isLoggedIn = await getUser();\n  return isLoggedIn ? <Dashboard /> : <Landing />;\n}\n```\n\n#### BETA 功能\n\n##### 1）服务器操作\n\nNext.js 13.4 引入了服务器操作（目前处于 alpha 版本），它为您的应用程序带来了更多的灵活性和强大功能。服务器操作允许您直接在应用程序中处理服务器端逻辑，例如获取数据或与 API 交互。此功能不仅简化了您的应用程序架构，还使您能够创建更快、更高效的应用程序。\n\n##### 2）Turbopack\n\n随着 Next.js 13.4 的发布，Turbopack 已进入测试阶段，提供功能更完整、更稳定的体验。 Turbopack 是 Next.js 基于 Rust 的新捆绑器，旨在加速开发中的本地迭代以及很快的生产构建。由于社区在测试和报告错误方面的支持，Turbopack 的采用率不断提高，为未来更快、更高效的开发体验铺平了道路。\n\n##### 3）草稿模式：轻松获取和渲染草稿内容\n\nNext.js 13.4 引入了[草稿模式](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode)，该功能允许您轻松地从无头 CMS 中获取和渲染草稿内容。与现有的预览模式 API 相比，草稿模式提供了更简化和增强的体验，新应用程序目录不支持现有预览模式 API。\n\n通过草稿模式，您现在可以在发布内容之前无缝预览和迭代内容，确保为用户提供最高质量的输出。\n\n什么是 CMS ？\n\n答：CMS 是 Content Management System（内容管理系统）的缩写。它是一种应用程序或一组相关的应用程序，用于创建、管理、分发、发布和更新内容。CMS 提供了一个集中化的仓库，使得你可以在其中收集，管理和发布信息。\n\n在前端开发的上下文中，CMS 通常会提供 API（如 RESTful 或 GraphQL API），前端应用则通过这些 API 与 CMS 进行交互，获取或修改数据。而 CMS 的内容通常包括了网页的文本、图片、视频等。\n\n有许多常见的 CMS，例如 Wordpress, Drupal, Joomla 等等。近年来，所谓的 \"headless CMS\" 也变得越来越流行，例如 Contentful, Prismic, Strapi 等。所谓 \"headless\"，是指在 CMS 不再负责内容的呈现，只通过 API 提供内容，因此可以更灵活地与各种前端框架和技术（例如React，Vue，Angular，或者静态网站生成器）结合使用。\n\n## 总结\n\n个人觉得 Next.js 是一种新的前端开发范式，通过使用 Next.js 13 ,学习到了很多新的概念，同时也觉得使用 Next.js 开发，没有之前流畅，需要学习的还有很多",
        "category": "文章",
        "cover": "https://pic.study/post_cover/1619930914211520514/txMz8DLl-nextjs13.4.webp",
        "language": null,
        "viewNum": 14,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-21T14:57:30.000+00:00",
        "updateTime": "2023-10-30T04:50:24.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 12,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-10-11T01:17:28.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "框架"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1714611420164911105",
        "title": "Spring-Security 实现RBAC 权限控制系统",
        "description": "总结",
        "content": "- #### 为什么需要使用权限管理框架?\n\n```java\n1.根据角色实现用户访问控制的实现逻辑基本一致,但开发的时候实现复杂,步骤重复\n2.简化开发步骤,实现相同代码逻辑快速开发让\n```\n\n- #### 常用的权限管理框架有哪些?\n\n  - Shrio  小型企业\n  - Security 中,大型企业\n\n\n\n- #### Security的基本原理是什么?\n\n  ```java\n  1.在用户请求进入tomcat 后 进入dispatcherServlet之前做预处理(过滤器)\n  2.Security的本质是实现了多个多个过滤器,在每个用户的请求做链式逻辑判断,一旦不符合中间某一个过滤器逻辑,就会被拦截\n  3.对未登录的用户拦截,并返回一个页面让其登录,进入loadUserByUsername()方法中逻辑处理\n  4.对登陆的用户保存serssion \n  5.记住我:将用户信息存入cookie 返回前端浏览器\n  6.CSRF :仿跨站伪造请求 钓鱼网站恶意获取用户信息,伪造正常用户发送请求,第一次访问时响应tooken,用户登陆时将tooken 提交\n  ```\n\n- #### 实际开发中,用户的信息从哪里来?\n\n  ```java\n  1.第一次登录时,根据用户传过来的用户名和密码,从mysql中拿取数据\n  2.登陆过,前端传过来cookie,根据cookie信息从redis 中拿取数据\n  ```\n\n- #### Security中如何实现密码加密?\n\n  ```\n  使用BCryptPasswordEncoder().encode();方法对明文密码使用Bcrypt加密方式加密\n  ```\n\n- #### 记住我的原理是什么?\n\n  ```java\n  记住我:将用户信息存入cookie 返回前端浏览器\n  ```\n\n- #### 什么是CSRF? 解决方案有哪些?\n\n  ```jav\n  1.验证 Referer域 是否是服务端自己认可的域名\n  2.第一次访问时响应tooken,用户登陆时将tooken 提交\n  ```\n\n- #### 获取用户认证信息\n\n  ```java\n  SecurityContextHolder.getContext().getAuthentication().getPrincipal()\n  ```\n\n## RBAC系统集成Security\n### Security的授权方式有哪些?如何使用?\n\n- 在配置类中定义哪个用户具有哪些角色或权限。\n- 在Controller的方法或类上贴上Security提供的注解(配置类需要启用注解@EnableGlobalMethodSecurity)\n\n### 如何处理没有权限时的异常?\n\n当用户没有权限时，Spring Security会抛出AccessDeniedException。\nSecurity 默认返回一个403视图页面,我们可以实现AccessDeniedHandler口自定义处理方式,通常返回Json 数据\n自定义的AccessDeniedException异常处理方式需要在security的配置类中添加:调用http.exceptionHandling()\n.accessDeniedHandler();\n\n### 用户的数据从哪里来?如何实现?\n\n- 用户数据来自数据库。\n- 实现UserDetailsService接口来加载用户数据。\n\n### 在项目中,如何获取到登录的员工信息?\n\n使用SecurityContextHolder来获取登录的员工信息，如用户名、角色等。\n\n### 认证器的作用是什么?如何使用认证器?\n\n- 认证器用于验证用户身份\n- 从上下文从获取用户信息再根据访问提供的用户明和密码作比较.\n\n\n### EmployeeServiceImpl中如何实现登录认证?\n\n1. 从Controller中接受到用户名和密码,然后将信息封装到UsernamePasswordAuthenticationToken中\n2. 调用认证器authenticationManager.authenticate()方法将Token对象传入认证\n3. 然后调用authenticate.getPrincipal()方法,获取用户信息,并存入Redis中\n4. 前提authenticate.getPrincipal()方法拿到的必须是UserDetails的实现类,且有对应登录的实体类属性.\n\n### Security如何检查用户是否有登录?\n\n1. 可以使用SecurityContextHolder.getContext().getAuthentication()来获取认证信息。\n2. 在自定义过滤器中判断用户是否传入Token,如果有就去Redis中获取对应的用户信息\n3. 将获取到的用户信息封装到UsernamePasswordAuthenticationToken中\n4. 后续过滤器等其他组件会先判断Security上下文是否有用户信息,有信息代表登录了.\n5. 自定义过滤器需要在其他过滤器可能会需要从Security上下文获取用户信息的前面执行,否则后面的过滤器链拿不到用户信息.\n\n### 在什么时候将用户的认证信息存储起来?\n\n用户的认证信息在登录时存储起来，认证成功后，Security会创建Authentication对象并存储在SecurityContext中。\n\n### 为什么需要调整过滤器的顺序?\n\n- 调整过滤器的顺序可以确保请求按照正确的顺序通过过滤器链。\n- 其他过滤器可能会需要从Security上下文获取用户信息,存入用户信息的过滤器如果不前面执行,后面的过滤器链拿不到用户信息.\n\n### Security从哪里获取用户的权限? 如何将用户的权限告知Security?\n\n- 用户的权限通常来自配置或数据库中的角色/权限信息。\n- 通过注解方式/配置类方式标识资源的权限\n- 通过UserDetails的实现类去获取用户的权限信息,并在自定义过滤器中存入Security的上下文中\n\n### 如何描述接口需要什么权限或者角色?\n\n- 在配置类中使用AntMatchers方法分配权限或角色\n- @PreAuthorize注解来描述接口需要的权限或角色。\n\n### 如何处理认证和授权失败的异常?\n\n- 自定义异常处理器\n- 配置Spring Security的异常处理来处理认证和授权失败的异常，通常会返回状态码和错误信息(Json)\n  \n  \n![image.png](https://pic.study/post_picture/1673111457186713601/fQNrKxSA-image.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 48,
        "thumbNum": 4,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-18T11:56:33.000+00:00",
        "updateTime": "2023-11-02T01:13:41.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.study/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-29T06:17:22.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712670027519488002",
        "title": "RBAC 基础 -权限控制",
        "description": null,
        "content": "## RBAC 角色权限控制\n\n### 1. 什么是 RBAC\n\nRBAC（Role-Based Access Control，基于角色的访问控制），是一种新的访问控制机制，\n它是以角色为中心来进行访问控制的，即用户通过角色与权限进行关联，进而获得权限，从而访问系统资源。\n\n#### 什么是ABAC(扩展--->框架少,实现比较困难,开发成本高,但一旦实现,可以实现很多复杂的控制)\n\nABAC（Attribute-Based Access Control，基于属性的访问控制），是一种新的访问控制机制，\n它是以属性为中心来进行访问控制的，即用户通过属性与权限进行关联，进而获得权限，从而访问系统资源。\n\n\n### 2. RBAC 的优点\n\nRBAC 的优点主要有以下几点：\n\n- 降低了复杂性：\n- 降低了维护成本\n- 降低了风险：\n- 降低了开发成本\n- 降低了运维成本\n- 降低了安全风险\n- 降低了系统复杂度\n- 降低了系统的耦合度\n- 降低了系统的依赖性\n\n### 3. RBAC 的分级\n- RBAC0：基本的RBAC模型，只有用户、角色、权限三个基本元素，是最简单的RBAC模型。\n- RBAC1：在RBAC0的基础上增加了角色继承，即角色可以继承其他角色的权限。\n- RBAC2：在RBAC1的基础上增加了用户-角色绑定，即用户可以绑定多个角色。\n- RBAC3：在RBAC2的基础上增加了约束，即角色可以绑定多个用户，但是每个用户对于某个角色的绑定都有时间上的限制。\n\n\n### 3. RABC 的核心\n\n- 用户（User）：用户是指系统的使用者，可以是一个人，也可以是一台机器，或者其他什么东西。\n- 角色（Role）：角色是指用户的职责或者角色，一个用户可以有多个角色，一个角色可以包含多个用户。\n- 权限（Permission）：权限是指用户在某个角色上可以执行的操作，一个角色可以包含多个权限，一个权限可以包含多个角色。\n- 资源（Resource）：资源是指用户可以访问的系统资源，比如文件、目录、数据库等。\n- 操作（Operation）：操作是指用户对资源可以执行的操作，比如读、写、执行等。\n- 会话（Session）：会话是指用户在一段时间内的访问，一般来说，用户登录系统后，就会建立一个会话，直到用户退出系统，这个过程就是一个会话。\n- 会话管理（Session Management）：会话管理是指对用户的会话进行管理，包括建立会话、维护会话、销毁会话等。\n- 会话控制（Session Control）：会话控制是指对用户的会话进行控制，包括会话的访问控制、会话的权限控制等。\n- 会话访问控制（Session Access Control）：会话访问控制是指对用户的会话进行访问控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限控制（Session Permission Control）：会话权限控制是指对用户的会话进行权限控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限管理（Session Permission Management）：会话权限管理是指对用户的会话进行权限管理，包括会话的访问控制、会话的权限控制等。\n- 会话权限分配（Session Permission Assignment）：会话权限分配是指对用户的会话进行权限分配，包括会话的访问控制、会话的权限控制等。\n\n# 4. RBAC 的实现\n## RBAC 系统\n\n### 1. 基于角色控制资源访问\n\n### 2. 数据库表设计 :\n\n### 用户表--->用户角色中间--->角色表--->角色资源中间表--->资源表\n\n### 3. 前后端构建\n\n##### 1.1 基于Vue 快速构建 \n\n##### 1.2 使用Element-Ui 快速渲染页面布局\n\n##### 1.3 spring-boot 快速构建web 项目\n\n\n\n### 4. 前后端数据交互\n\n###### 1.1.1 构建表格页面\n\n- ##### 基本CURD 的数据交互\n\n###### 1.2.2 基本实现分页数据展示--->获取当前分页条的数据--->发送Axios请求 拿去分页数据\n\n###### ---> 后端接搜数据 ---> 查询全部信息(涉及时间的字段使用@JsonFromat(....)),通过分页插件PageHelper,将list集合封装到PageInfo中,返回JsonResult \n\n###### 1.2.2 实现基本删除 ----->点击删除按钮,通过插槽 scope,获取到当前行的数据---> 发送Axios 请求 --->后端接受到当前行的id(主键iD)-->执行删除SQL 语句\n\n\n\n###### 1.2.3 实现批量删除的方法 ---> 勾选时,给定状态,当点击批量删除时,遍历该状态的行,拿去取主键ID存入集合,发送Psot请求,将数组通过qs.tistringify方法(设置不需要数组索引)将书据转换成json格式,设置发送方式将数据转换成表单(www---???),----> 后端接受数据List<>,或数组都可以(使用@RequestParam 接收)--->拿到数组,执行SQL语句,通过动态SQL 遍历传过来的数组,执行数据的删除.\n\n###### 1.2.3 实现新增功能 -->点击新增按钮弹出新增表单,输入数据,点击提交时--->发送Axios请求,将表单数据提交到后端处理-->后端拿到对应的实体类对象数据--->执行新增SQL语句(设置时间可以使用NOW() )\n\n\n\n###### 1.2.4 实现并编辑功能-->点击编辑,回显数据,拿到当前行的全部数据-->发送Axios请求把实体类对象传入后端--->后端接受参数,执行修改的SQL语句(动态SQL if 判断字段)\n\n\n\n\n\n###### 1.2.5 在分页功能的基础上增加过滤查询,动态sql 判断\n\n- #### 树形结构数据\n\n  ##### 1.1 动态菜单查询\n\n  ###### 1.1.1 遍历 \n\n  ```java\n  1. 思路: 遍历方式用于获取树形结构数据中的每一个节点，通常使用迭代方法来实现。\n  \n  2. 代码逻辑:\n     - 初始化一个队列或栈，将根节点加入其中。\n     - 进入循环，直到队列或栈为空。\n     - 在每次迭代中，弹出队列或栈中的一个节点，处理它的数据。\n     - 如果节点有子节点，将子节点加入队列或栈，以便后续处理。\n  ```\n\n  \n\n  ###### 1.1.2 递归调用\n\n  ```java\n  1. 思路: 递归方式用于获取树形结构数据中的每一个节点，通常使用递归方法来实现。\n  \n  2. 代码逻辑:\n     - 创建一个递归函数，接受当前节点作为参数。\n     - 在递归函数中，处理当前节点的数据。\n     - 如果当前节点有子节点，对每个子节点调用递归函数。\n     - 递归会一直深入子节点，直到到达叶子节点。\n  \n  ```\n\n  \n\n  ###### 1.1.3 sqL 语句\n\n  ```sql\n  <!-- 循环的 SQL -->\n  SELECT * FROM menu WHERE parent_id = 0; -- 获取根节点\n  \n  <!-- 递归的 SQL -->\n  WITH RECURSIVE MenuTree AS (\n      SELECT * FROM menu WHERE parent_id = 0 -- 获取根节点\n      UNION ALL\n      SELECT m.* FROM menu m\n      INNER JOIN MenuTree mt ON m.parent_id = mt.id\n  )\n  SELECT * FROM MenuTree;\n  -- 递归查询的 SQL 使用了公共表达式（CTE）和 UNION ALL，以获取所有层级的子菜单。\n  \n  ```\n\n- ##### 穿梭框 数据交互 查询  分配角色--->用户_角色表\n\n  ###### 1.1 前端页面\n\n  ###### 1.2 拿取所有角色\n\n  ###### 1.3 通过分配按钮拿去当前用户id 查询所拥有的角色\n\n  ###### 1.4 判断用户是否更改过穿梭框的数据,校验是否有数据---有--->拿到当前表数据,发送请求--->后端接受请求获取参数-->拿到 用户ID 先执行删除角色的Sql --->删除成功后新增角色数据(先删后改--->保证事务的一致性)\n\n  \n\n- #####   角色分配权限  角色表_权限中间表 -->权限表\n\n  ###### 0 --> 页面加载时获取 所有权限\n\n  ###### 1.1 前端点击分配按钮 --->弹出表单数据\n\n  ###### 1.2 发送 请求查询当前拥有的权限--->SQL 查询-->回显数据\n\n  ###### 1.3 修改后提交--->拿到表单数据,发送请求--->后端接受请求获取参数,拿到 角色ID 先执行删除已有权限的Sql --->删除成功后新增表单权限数据(先删后改--->保证事务的一致性)\n\n- ##### 登陆相关权限验证\n\n  - ###### 登录\n\n    1.前端页面提交表单数据--->发送请求\n\n    2.后端接受请求,检查数据是否正常\n\n    3.正常:查询SQL 拿取对应的user信息,判断数据是否和前端传过来的一致\n\n    4:一致:用UUID生成Token,调用Spring-boot中Redis(RedisTemplate.opsForValue().set())方法,以Token为key,对象为value存入Redis中(对应实体类应支持序列化)\n\n    5.返回Token\n\n    6.前端接受数据,VueX将数据存入请求头\n\n    7.立即调用Info 方法,根据Token获取对应的用户信息\n\n  - ###### 获取信息\n\n    1.VueX调用Info 方法,根据Vuex中存入的Token获取对应的用户信息\n\n    2.后端接受请求,从请求头中获取Token(@RequestHeader)\n\n    3.校验数据,有没有传Token,有,判断Token是否有效\n\n    4.从Redis中获取用户信息(RedisTemplate.opsForValue().get())\n\n    5.将数据返还后端\n\n  - ###### 登出\n\n    1.  点击退出登录按钮发送登出请求\n    1.  后端接受到请求,从请求头中获取Token\n    1.  拿到Token,调用RedisTemplate.delet()方法\n    1.  返回成功的状态信息\n    1.  前端Vuex接受成功响应,从前端重置Token,刷新页面\n\n\n#### 5.请求拦截器 \n\n- ##### 判断登录请求拦截器\n\n  1.自定义登录拦截器,继承HandlerInterceptorAdapter或实现HandlerInterceptor   (交给容器管理)\n\n  2.实现preHandle\n\n  3.逻辑判断处理\n\n  ```java\n  1.获取请求头中的Token\n  2.根据Token去Redis中查询对应的用户信息\n  3.有信息,放行  没有拦截\n  ```\n\n  4.将自定义拦截器注册到Spring-Mvc 中\n\n  5.编写 WebMvcConfigurer 配置类,实现\n\n  ```java\n  // 注册拦截器\n          registry.addInterceptor(checkLoginInterceptor) // 将自定义拦截器注入到mvc中\n                  .addPathPatterns(\"/**\") // 设置需要拦截的路径 /** 表示拦截所有请求\n                  .excludePathPatterns(\"/users/login\"); // 设置排除的路径 登录请求不需要拦截\n  ```\n\n  \n\n- ##### 访问资源权限请求拦截器\n\n  1.定义注解,贴在方法上来解释该方法请求的资源对应需要的权限\n\n  2.自定义拦截器\n\n  3.逻辑判断处理\n\n  ​\t3.1 是否是超级管理员权限\n\n    ```java\n    1.获取请求头中的Token\n    2.根据Token去Redis中查询对应的用户信息\n    3.是管理员,可以访问所有路径,放行\n    ```\n\n​\t\t\t3.2 判断用户访问的资源是否需要权限\n\n```java\n1.获取访问资源的路径方法\nHandlerMethod handlerMethod = (HandlerMethod) handler;\n2获取方法上的注解\nhandlerMethod.getMethodAnnotation(RequiredPermission.class); //传入自定义注解字节码通过反射获取value值\n3.如果拿不到该注解,说明不需要权限,直接放行\n```\n\n​\t\t\t3.3 判断该用户是否具有该注解的对应数据\n\n```java\n1.通过用户id  关联 用户和角色中间表 \n2.再通过角色id 关联 角色和权限中间表\n3.再同过权限id 查询 对应的权限表达式\n4. 一个用户可能会有多个权限 ,且权限可能重复(去重)\n5.拿到权限表达式集合判断是否包含当前访问资源的权限\n6.有.放行   没有 : 拦截\n```\n\n![image-20231017224134744](C:\\Users\\33960\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231017224134744.png)\n\n### 6. 优化逻辑\n\n- ##### 常量类抽取:   对常用字符串,数字等抽取\n\n- ##### 自定义异常:在代码中,如出现逻辑判断会抛出一些异常,如果用RuntimeException(),Exception都会难以快速定位\n\n- ##### 统一异常处理:将异常统一处理不用在可能出现异常的代码上都使用tar catch 包围,还可以指定自定义异常的处理方式\n\n- ##### 方法抽取:将一些多次使用的代码抽离出来定义成工具类,增加复用性\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 41,
        "thumbNum": 4,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T03:22:09.000+00:00",
        "updateTime": "2023-11-01T03:08:54.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.study/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-29T06:17:22.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712664270979854337",
        "title": "NoSqol-Redis 基础",
        "description": "NoSql -Redis",
        "content": "## NoSql\n\n### 什么是NoSQL\n- NoSQL(Not only SQL):不仅仅是Sql,是对不同于传统的关系数据库(以二维表结构展示)的数据库管理系统的统称\n- NoSql 与Sql 之间不是对立关系,而是作为Sql的补充,满足在特殊需求上,Sql实现复杂,效率低等问题...\n\n### 常见类型的NoSql\n\n- 键值数据库 以 key-value 的形式存储数据  -->Redis\n- 文档数据库 以Document的形式存储  --->MongoDB,Elasticsearch\n- 图类型数据库 图结构  --->Neo4J\n- 列族数据库 以列族式存储，将同一列数据存在一起 -->HBase\n\n 扩展:\n \n     1 .https://blog.csdn.net/weixin_44259720/article/details/104839050\n     2. https://zhuanlan.zhihu.com/p/345342966\n## Redis\n\n### 什么是Redis\n- 以 key-value 形式存储,和传统的关系型数据库不一样.不一定遵循传统数据库的一些基本要求.(非关系型的,分布式的,开源的,水平可拓展的)\n\n- Redis 是以 key-value store 存储.\n        \n        键可以包含:(string)字符串,哈希,(list)链表,(set)集合,(zset)有序集合.\n        这些数据集合都指出push/pop,add/remove及取交集和并集以及更丰富的操作.\n        redis支持各种不同方式排序,为了保证效率,数据都是缓存在内存中.\n        它可以从周期性的把更新的数据写入到磁盘或者把修改操作写入追加的文件中.\n### 优缺点\n\n\n- 优点:\n\n```text\n高并发读写\n海量数据的高效率存储和访问\n数据的可拓展性和高可用性\n单线程操作,每个操作都是原子操作,没有并发相关问题\n```\n\n- 缺点:\n```text\n事务处理非常简单\n无法做太复杂的关系数据库模型\n基于内存容易丢失数据\n```\n\n### 使用场景\n\n#### 缓存中间件\n\n- Redis 缓存的优缺点\n```text\n\t优点\n\t\t提高查询性能, 减少 IO 操作\n\t\t减轻 MySQL 数据库负担\n\t\t减轻应用服务器 cpu & 内存负担\n\t缺点\n\t\t数据一致性问题\n\t\t可能丢失数据\n```\n- 什么数据适合做缓存?\n```text\n\t查询频率高\n\t修改频率低\n\t一致性要求较低\n```\n- 缓存操作流程\n```text\n\t1. 读取 redis 数据，有则直接返回\n\t2. redis 中没有，查询 mysql 数据库\n\t3. 将 mysql 数据库的数据存储到 redis\n\t4. 返回该数据\n```\n\n### NoSql\n\n- NoSQL 应用场景\n 1. 数据频繁更新且一致性要求不高\n \n\t\t阅读数/评论数/分享数等\n\t\t接口限流\n2. 基于 List 实现栈/队列等特殊结构\n3. 基于经纬度的地理位置操作--->Redis GEO\n\n\n\n\n\n\n# 常见命令和基本五大数据类型\n \n### 全局命令\n\n| 命令               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `PING`             | 测试连接是否正常                                             |\n| `INFO`             | 获取服务器信息                                               |\n| `FLUSHALL`         | 删除所有数据库的所有数据                                     |\n| `FLUSHDB`          | 删除当前数据库的所有数据                                     |\n| `SELECT`           | 选择数据库                                                   |\n| `AUTH`             | 使用密码进行认证                                             |\n| `KEYS`             | 查找所有符合给定模式的键                                     |\n| `EXPIRE`           | 设置键的过期时间                                             |\n| `TTL`              | 获取键的剩余过期时间                                         |\n| `DEL`              | 删除键                                                       |\n| `RENAME`           | 重命名键                                                     |\n| `DBSIZE`           | 获取当前数据库中键的数量                                     |\n| `SCAN`             | 迭代数据库中的键                                             |\n| `EVAL`             | 执行Lua脚本                                                  |\n| `SCRIPT LOAD`      | 加载Lua脚本                                                  |\n| `SCRIPT EXECUTE`   | 执行已加载的Lua脚本                                          |\n| exists key         | 判断 key 是否存在, 返回 1 或 0, 1表示存在, 0表示不存在       |\n| ttl key            | 返回指定 key 还有多少秒过期, 如果已经过期或者不存在, 返回 -2, 如果没有设置过期时间, 返回 -1 |\n| expire key seconds | 为指定 key 设置过期时间为 seconds 秒, 如果之前已经设置了过期时间, 会直接覆盖之前的 |\n| flushdb            | 清除 redis                                                   |\n| keys pattern       | 按照指定格式扫描所有 key, 返回匹配的 key 集合                |\n\n### 常用数据类型命令\n\n### String\n\n| 命令                  | 描述                                             |\n|----------------------|--------------------------------------------------|\n| `SET key value`      | 存储一个键值对                                    |\n| `GET key`            | 获取指定键的值                                    |\n| `INCR key`           | 原子性地将键的值加1                               |\n| `DECR key`           | 原子性地将键的值减1                               |\n| `INCRBY key value`   | 原子性地将键的值增加指定值                        |\n| `DECRBY key value`   | 原子性地将键的值减少指定值                        |\n| `SETEX key seconds value` | 设置键值对的同时，设置过期时间               |\n| `SETNX key value`    | 如果键不存在则设置，返回1；如果键已存在则不设置，返回0（原子性操作） |\n| `MSET key1 value1...keyn valuen` | 设置多个键值对  |\n| `MGET key1 key2 keyn` | 获取多个指定键的值                             |\n\n#### 应用场景\n\n- 计数器（如浏览数、评论数、点赞数等）\n- 分布式自增ID生成器\n- 共享Session\n\n### Hash\n\n| 命令                          | 描述                                            |\n|------------------------------|-------------------------------------------------|\n| `HSET key field value`       | 存储一个键值对到hash结构，键名为key，字段为field，值为value |\n| `HGET key field`             | 获取指定hash结构中field的值                     |\n| `HKEYS key`                  | 获取hash结构下指定key的所有字段名                  |\n| `HVALS key`                  | 获取hash结构下指定key的所有字段值                  |\n| `HINCRBY key field value`    | 原子性地将指定hash结构key中的field增加value（field必须是数字） |\n| `HGETALL key`                | 一次性返回指定hash key中的所有键值对              |\n\n#### 应用场景\n\n- 存储复杂类型的属性\n- 减少外部键数量，通过hash对数据进行分类，将同一分类下的数据存储在hash中\n\n\n\n\n\n### List\n\n| 命令                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| `RPUSH key value...`    | 往列表（List）的最后添加一个或多个元素                       |\n| `LINDEX key index`      | 获取列表中指定索引位置的元素                                 |\n| `LRANGE key start stop` | 获取列表中从指定的 start 索引到 stop 索引位置范围内的所有元素 |\n| `LLEN key`              | 返回列表中的元素个数                                         |\n| `LREM key count value`  | 删除列表中指定值为 value 的元素                              |\n|                         | - count > 0：从头到尾删除 count 个元素                       |\n|                         | - count < 0：从尾到头删除 count 个元素                       |\n|                         | - count = 0：删除所有值为 value 的元素                       |\n| `LPUSH`/`RPOP`          | 用于实现队列，支持先进先出（FIFO）                           |\n| `LPUSH`/`BRPOP`         | 用于实现阻塞队列，支持先进先出（FIFO），在获取不到元素时线程会阻塞等待 |\n| `LPUSH`/`LPOP`          | 用于实现栈，支持先进后出（LIFO）                             |\n\n#### 应用场景\n\n- 用作各种列表类型的数据结构\n  - 普通列表\n  - 队列/阻塞队列\n  - 栈\n- 关注人集合/粉丝集合/收藏文章集合等\n  - 注意处理大键（Key）的情况\n\n\n\n\n\n### Set\n\n| 命令                    | 描述                                           |\n| ----------------------- | ---------------------------------------------- |\n| `SADD key members...`   | 往集合（Set）中添加一个或多个成员              |\n| `SCARD key`             | 返回集合中的成员数量                           |\n| `SMEMBERS key`          | 返回集合中的所有成员                           |\n| `SDIFF key1 key2`       | 返回两个集合 key1 和 key2 的差集               |\n| `SINTER key1 key2`      | 返回两个集合 key1 和 key2 的交集               |\n| `SUNION key1 key2`      | 返回两个集合 key1 和 key2 的并集               |\n| `SPOP key count`        | 随机移除并返回集合 key 中的 count 个成员       |\n| `SRANDMEMBER key count` | 随机返回集合 key 中的 count 个成员（允许重复） |\n\n#### 应用场景\n\n- 求交集、并集、差集的需求\n- 数据去重、获取随机数\n- 抽奖功能等\n\n\n\n### Sorted Set 类型(ZSet)\n\n| 命令                                 | 描述                                                   |\n| ------------------------------------ | ------------------------------------------------------ |\n| `ZADD key score value`               | 往有序集合（ZSet）中添加一个带有分数的成员             |\n| `ZCARD key`                          | 返回有序集合中的成员数量                               |\n| `ZCOUNT key min max`                 | 返回有序集合中分数在 min 和 max 之间的成员数量         |\n| `ZINCRBY key score value`            | 为有序集合中的指定成员增加分数                         |\n| `ZRANGE key startIndex stopIndex`    | 根据分数从小到大的排序，返回有序集合的指定成员列表     |\n| `ZREVRANGE key startIndex stopIndex` | 根据分数从大到小的排序，返回有序集合的指定成员列表     |\n| `ZRANK key value`                    | 返回有序集合中指定成员的排名（从小到大的排序索引位置） |\n| `ZREVRANK key value`                 | 返回有序集合中指定成员的排名（从大到小的排序索引位置） |\n| `ZREM key value`                     | 从有序集合中删除指定成员                               |\n| `ZSCORE key value`                   | 返回有序集合中指定成员的分数                           |\n\n#### 应用场景\n\n- 排行榜应用场景，如游戏得分排名\n- 带权重的元素排序，如商品价格排名\n- 实时热门内容排行等\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 21,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:59:16.000+00:00",
        "updateTime": "2023-11-01T07:52:17.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.study/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-29T06:17:22.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis",
          "SQL"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712659313811648513",
        "title": "RESTFUL-风格完成后端接口开发",
        "description": "REST ",
        "content": "## REST\n\n### REST风格 API接口开发\n\n#### 1. RESTful (核心思想===>表现层状态转换)\n\n1.1 RESTful是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。\n\n1.2 RESTful是目前最流行的一种互联网软件架构。\n\n1.3 RESTful架构的核心原则：\n```text\n1- 以资源为中心，资源是指网络上的一个实体，或者说是网络上的一个具体信息。\n- 每个资源对应一个特定的资源路径，即URI。\n- 客户端和服务器之间，传递这种资源的某种表现层状态，即表现层状态转换。\n\n以资源为基础 ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，\n除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。\n\n2- 统一接口：统一接口是RESTful架构的基础，只要是符合RESTful架构原则的，都可以称为RESTful接口。\n- 统一接口包括：资源标识、资源操作、自描述消息、超媒体作为应用状态引擎。\n- 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。\n- GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。\n- DELETE（DELETE）：从服务器删除资源\n- 通过统一接口，实现了客户端和服务器的分离，使得客户端不用关心服务器的技术实现，而服务器也不用关心客户端的业务逻辑。\n```\n传统API接口开发和RESTful API接口开发对比：\n\n| 传统API接口开发 | RESTful API接口开发 |\n| :--- | :--- |\n| 以动作为中心 | 以资源为中心 |\n| 以动词为中心 | 以名词为中心 |\n| 以操作为中心 | 以数据为中心 |\n| 以过程为中心 | 以结果为中心 |\n| 以业务为中心 | 以实体为中心 |\n\n![image.png](https://pic.study/post_picture/1673111457186713601/edLHAoeZ-image.png)\n\n#### 2. RESTful URI设计\n1. 不用大写字母，所有单词使用英文且小写。\n2. 连字符用中杠\"-\"而不用下杠\"_\"\n3. 正确使用 \"/\"表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定\n4. 结尾不要包含正斜杠分隔符\"/\"\n5. URL中不出现动词，用请求方式表示动作\n6. 资源表示用复数不要用单数\n7. 不要使用文件扩展名\n8. 用好HTTP状态码\n\n#### 3. RESTful 响应状态码\n使用RESTful风格的API接口开发，一般需要返回响应状态码和响应数据，\n响应状态码的使用非常重要，下面列举了常用的状态码：\n\n```text\n1. 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n2. 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n3. 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n4. 204 NO CONTENT - [DELETE]：用户删除数据成功。\n5. 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n6. 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n7. 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n8. 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n9. 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n10. 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n11. 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n12. 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n```\n\n#### 4.日常开发使用\n\nRestful 只是一种风格和规范,不是一种标准,不一定要让所有接口全部遵循,一般开发中混用.",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 24,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:39:34.000+00:00",
        "updateTime": "2023-10-30T08:46:48.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.study/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 14,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-29T06:17:22.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "API接口",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "182",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "23"
  },
  "message": "ok"
}